# Copyright 2020 Alibaba Group Holding Limited. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# =============================================================================
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import numpy as np
from graphlearn.python.nn.tf.module import Module
from graphlearn.python.nn.tf.data.feature_group import FeatureHandler

class EgoGraph(Module):
  def __init__(self,
               vertices,
               neighbors,
               schema,
               hops):
    """ EgoGraph is designed to simplify data structures of the results
    generated by GSL and corresponding transformation. Its fields can be
    np.ndarray or tf.Tensor format. You can access the vertices and their
    neighbors through EgoGraph easily.

    Args:
      vertices: A Vertex object or a tf.Tensor.
      neighbors: A list of Vertex objects or tf.Tensor.
      schema: A list of tuple to describe the FeatureSpec of vertices and
        neighbors. Each tuple is formatted with (name, spec), in which `name`
        is a string, and `spec` is a FeatureSpec object. Be sure that
        `len(schema) == len(neighbors) + 1`.
      hops: Neighbor count list. If 2-hop neighbors will be sampled for centric
        vertices, we can assign hops like `[10, 5]`, the element in which
        represents the neighbor count at corresponding hop.
    """
    self.vertices = vertices
    self.neighbors = neighbors
    self.schema = schema

    if self.schema is not None:
      assert len(self.schema) == len(self.neighbors) + 1

    if isinstance(hops, list):
      self.hops = np.array(hops)
    else:
      self.hops = hops

  @property
  def nodes(self):
    """ Get the centric vertices when GSL starting from a kind of vertex. The
    return value is a tensor with shape [batch_size, dim], where dim is the sum
    of all feature dimensions.
    """
    return self.vertices

  @property
  def expands(self):
    """ Get the neighbor count at each hop. The return value is a np.ndarray
    object. If sampling 2-hop neighbors for centric vertices in GSL, such as
    the first hop is 10 and the second hop is 5, the return value is
    np.array([10, 5]).
    """
    return self.hops

  def hop(self, i):
    """ Get the hop ith neighbors of centric vertices, where i starts from zero.
    The return value is a tensor with shape [batch_size * k_1 *...* k_i, dim],
    where k_i is the expand neighbor count at hop i and dim is the sum of all
    feature dimensions, which may be different due to kinds of vertex types.
    """
    return self.neighbors[i]

  def forward(self, shared_param=None):
    if self.schema is None:
      return self

    assert len(self.schema) == (len(self.neighbors) + 1)

    s = self.schema[0]
    vertex_handler = FeatureHandler(s[0], s[1])
    vertex_tensor = vertex_handler.forward(self.vertices)

    neighbors = []
    for i, nbr in enumerate(self.neighbors):
      s = self.schema[i + 1]
      neighbor_handler = FeatureHandler(s[0], s[1])
      neighbor_tensor = neighbor_handler.forward(self.neighbors[i])
      neighbors.append(neighbor_tensor)

    return EgoGraph(vertex_tensor, neighbors, None, self.hops)
